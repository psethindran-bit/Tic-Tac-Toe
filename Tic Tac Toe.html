<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Tic Tac Toe</title>
<style>
  body {
    font-family: lucida brght, sans-serif;
    display: flex; flex-direction: column;
    align-items: center;
    background:  linear-gradient(135deg, rgba(12,236,188,0.7), rgba(30,144,255,0.7)),
        linear-gradient(to bottom right, rgba(0,0,0,0.6), rgba(0,0,0,0.9)),
        url('https://images.unsplash.com/photo-1506744038136-46273834b3fb?auto=format&fit=crop&w=1470&q=80') no-repeat center center fixed;
    padding: 20px;
  }
  h1 {
    margin-bottom: 10px;
  }
  #settings {
    margin-bottom: 15px;
  }
  label {
    margin-right: 10px;
  }
  select, button {
    margin-right: 20px;
    padding: 5px 10px;
    font-size: 1rem;
  }
  #board {
    display: grid;
    gap: 5px;
    margin-top: 20px;
  }
  .cell {
    background: white;
    border: 2px solid #333;
    font-size: 2.5rem;
    display: flex;
    justify-content: center;
    align-items: center;
    cursor: pointer;
    user-select: none;
    font-weight: bold;
    color: #444;
    width: 80px;
    height: 80px;
  }
  .cell.disabled {
    cursor: default;
    color: #999;
  }
  #message {
    margin-top: 20px;
    font-weight: bold;
    font-size: 1.25rem;
    min-height: 1.5em;
  }
  #resetBtn {
    margin-top: 10px;
    padding: 8px 16px;
    font-size: 1.1rem;
  }
</style>
</head>
<body>

<h1>Tic Tac Toe</h1>

<div id="settings">
  <label for="gridSize">Grid size:</label>
  <select id="gridSize">
    <option value="3" selected>3 x 3</option>
    <option value="4">4 x 4</option>
  </select>

  <label for="playerSymbol">Choose your symbol:</label>
  <select id="playerSymbol">
    <option value="X" selected>X</option>
    <option value="O">O</option>
  </select>

  <label for="gameMode">Play against:</label>
  <select id="gameMode">
    <option value="human" selected>Human</option>
    <option value="easy">Computer (Easy)</option>
    <option value="medium">Computer (Medium)</option>
    <option value="hard">Computer (Hard)</option>
  </select>

  <button id="startBtn">Start Game</button>
</div>

<div id="board"></div>

<div id="message"></div>

<button id="resetBtn" style="display:none;">Reset Game</button>

<script>
  const boardEl = document.getElementById('board');
  const messageEl = document.getElementById('message');
  const gridSizeSelect = document.getElementById('gridSize');
  const playerSymbolSelect = document.getElementById('playerSymbol');
  const gameModeSelect = document.getElementById('gameMode');
  const startBtn = document.getElementById('startBtn');
  const resetBtn = document.getElementById('resetBtn');

  let gridSize = 3;
  let board = [];
  let currentPlayer;
  let humanPlayer, aiPlayer;
  let gameMode;
  let gameActive;
  let winLength;
  let cells;

  startBtn.addEventListener('click', startGame);
  resetBtn.addEventListener('click', resetGame);

  function startGame() {
    gridSize = parseInt(gridSizeSelect.value);
    humanPlayer = playerSymbolSelect.value;
    aiPlayer = humanPlayer === 'X' ? 'O' : 'X';
    gameMode = gameModeSelect.value;
    winLength = gridSize === 3 ? 3 : 4; // To win: 3 in row for 3x3, 4 for 4x4

    board = Array(gridSize * gridSize).fill('');
    currentPlayer = 'X'; // X always starts

    boardEl.style.gridTemplateColumns = `repeat(${gridSize}, 80px)`;
    boardEl.style.gridTemplateRows = `repeat(${gridSize}, 80px)`;
    boardEl.innerHTML = '';

    for (let i = 0; i < gridSize * gridSize; i++) {
      const cell = document.createElement('div');
      cell.classList.add('cell');
      cell.dataset.index = i;
      cell.addEventListener('click', onCellClick);
      boardEl.appendChild(cell);
    }

    cells = boardEl.children;
    messageEl.textContent = `Turn: ${currentPlayer}`;
    gameActive = true;
    resetBtn.style.display = 'inline-block';

    // If AI starts (human chose O and mode != human)
    if (gameMode !== 'human' && currentPlayer !== humanPlayer) {
      aiMove();
    }
  }

  function resetGame() {
    startGame();
  }

  function onCellClick(e) {
    const idx = e.target.dataset.index;
    if (!gameActive || board[idx] !== '') return;

    if (gameMode !== 'human' && currentPlayer !== humanPlayer) {
      // Not player's turn in AI mode
      return;
    }

    makeMove(idx, currentPlayer);

    if (!gameActive) return;

    switchPlayer();

    if (gameMode !== 'human' && currentPlayer === aiPlayer) {
      setTimeout(aiMove, 400);
    }
  }

  function makeMove(idx, player) {
    board[idx] = player;
    const cell = cells[idx];
    cell.textContent = player;
    cell.classList.add('disabled');
    // Check for winner or draw
    if (checkWinner(player)) {
      messageEl.textContent = `Player ${player} wins!`;
      gameActive = false;
      disableBoard();
    } else if (board.every(cell => cell !== '')) {
      messageEl.textContent = `It's a draw!`;
      gameActive = false;
    } else {
      messageEl.textContent = `Turn: ${currentPlayer === 'X' ? 'O' : 'X'}`;
    }
  }

  function switchPlayer() {
    currentPlayer = currentPlayer === 'X' ? 'O' : 'X';
    if (gameActive) {
      messageEl.textContent = `Turn: ${currentPlayer}`;
    }
  }

  function disableBoard() {
    for (let cell of cells) {
      cell.classList.add('disabled');
    }
  }

  function checkWinner(player) {
    // Check rows, columns, and diagonals for winLength in a row
    const lines = [];

    // Rows
    for (let r = 0; r < gridSize; r++) {
      lines.push(Array.from({length: gridSize}, (_, i) => r * gridSize + i));
    }
    // Columns
    for (let c = 0; c < gridSize; c++) {
      lines.push(Array.from({length: gridSize}, (_, i) => i * gridSize + c));
    }
    // Diagonal top-left to bottom-right
    let diag1 = [];
    for (let i = 0; i < gridSize; i++) diag1.push(i * gridSize + i);
    lines.push(diag1);
    // Diagonal top-right to bottom-left
    let diag2 = [];
    for (let i = 0; i < gridSize; i++) diag2.push(i * gridSize + (gridSize - 1 - i));
    lines.push(diag2);

    function checkConsecutive(line) {
      let count = 0;
      for (let idx of line) {
        if (board[idx] === player) count++;
        else count = 0;
        if (count === winLength) return true;
      }
      return false;
    }

    // Check all lines
    for (let line of lines) {
      if (checkConsecutive(line)) return true;
    }

    if (gridSize > 3) {
      // Check horizontal segments
      for (let r = 0; r < gridSize; r++) {
        for (let start = 0; start <= gridSize - winLength; start++) {
          let segment = [];
          for (let i = start; i < start + winLength; i++) {
            segment.push(r * gridSize + i);
          }
          if (checkConsecutive(segment)) return true;
        }
      }
      // Check vertical segments
      for (let c = 0; c < gridSize; c++) {
        for (let start = 0; start <= gridSize - winLength; start++) {
          let segment = [];
          for (let i = start; i < start + winLength; i++) {
            segment.push(i * gridSize + c);
          }
          if (checkConsecutive(segment)) return true;
        }
      }
      // Check diagonal segments (top-left to bottom-right)
      for (let r = 0; r <= gridSize - winLength; r++) {
        for (let c = 0; c <= gridSize - winLength; c++) {
          let segment = [];
          for (let i = 0; i < winLength; i++) {
            segment.push((r + i) * gridSize + (c + i));
          }
          if (checkConsecutive(segment)) return true;
        }
      }
      // Check diagonal segments (top-right to bottom-left)
      for (let r = 0; r <= gridSize - winLength; r++) {
        for (let c = winLength - 1; c < gridSize; c++) {
          let segment = [];
          for (let i = 0; i < winLength; i++) {
            segment.push((r + i) * gridSize + (c - i));
          }
          if (checkConsecutive(segment)) return true;
        }
      }
    }

    return false;
  }

  // AI moves including hard level with Minimax

  function aiMove() {
    if (!gameActive) return;
    let move;

    if (gameMode === 'easy') {
      move = getRandomMove();
    } else if (gameMode === 'medium') {
      move = getBestMoveMedium();
    } else if (gameMode === 'hard') {
      move = getBestMoveHard();
    }

    if (move !== undefined) {
      makeMove(move, aiPlayer);
      if (gameActive) {
        switchPlayer();
      }
    }
  }

  function getRandomMove() {
    const emptyCells = board
      .map((val, idx) => val === '' ? idx : null)
      .filter(v => v !== null);
    const randomIndex = Math.floor(Math.random() * emptyCells.length);
    return emptyCells[randomIndex];
  }

  function getBestMoveMedium() {
    // Try winning move
    for (let i = 0; i < board.length; i++) {
      if (board[i] === '') {
        board[i] = aiPlayer;
        if (checkWinner(aiPlayer)) {
          board[i] = '';
          return i;
        }
        board[i] = '';
      }
    }
    // Try blocking player's winning move
    for (let i = 0; i < board.length; i++) {
      if (board[i] === '') {
        board[i] = humanPlayer;
        if (checkWinner(humanPlayer)) {
          board[i] = '';
          return i;
        }
        board[i] = '';
      }
    }
    // Else random
    return getRandomMove();
  }

  // Hard AI using Minimax algorithm
  function getBestMoveHard() {
    let bestScore = -Infinity;
    let move;
    for (let i = 0; i < board.length; i++) {
      if (board[i] === '') {
        board[i] = aiPlayer;
        let score = minimax(board, 0, false);
        board[i] = '';
        if (score > bestScore) {
          bestScore = score;
          move = i;
        }
      }
    }
    return move;
  }

  // Scores: +10 win for AI, -10 win for human, 0 draw
  function minimax(boardState, depth, isMaximizing) {
    if (checkWinner(aiPlayer)) return 10 - depth;
    if (checkWinner(humanPlayer)) return depth - 10;
    if (boardState.every(cell => cell !== '')) return 0;

    if (isMaximizing) {
      let maxEval = -Infinity;
      for (let i = 0; i < boardState.length; i++) {
        if (boardState[i] === '') {
          boardState[i] = aiPlayer;
          let evalScore = minimax(boardState, depth + 1, false);
          boardState[i] = '';
          maxEval = Math.max(maxEval, evalScore);
        }
      }
      return maxEval;
    } else {
      let minEval = Infinity;
      for (let i = 0; i < boardState.length; i++) {
        if (boardState[i] === '') {
          boardState[i] = humanPlayer;
          let evalScore = minimax(boardState, depth + 1, true);
          boardState[i] = '';
          minEval = Math.min(minEval, evalScore);
        }
      }
      return minEval;
    }
  }

</script>

</body>
</html>
